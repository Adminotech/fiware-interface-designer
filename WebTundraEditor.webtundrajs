define([
        "lib/classy",
        "lib/three",
        "core/framework/Tundra",
        "core/script/IApplication",
        "core/scene/Scene",
        "core/scene/IComponent",
        "core/scene/Attribute",
        "core/scene/AttributeChange",
        "core/math/Transform",
        "core/frame/AsyncHelper",
        "application/editor/InterfaceDesigner-main"
    ], function(Class, THREE, Tundra, IApplication, Scene, IComponent, Attribute, AttributeChange, Transform, AsyncHelper, _Editor) {

var AddEntityCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, components, name, replicated, temporary)
    {
        if (isNull(name))
            name = "";
        if (isNull(replicated))
            replicated = true;

        var commandLabel = "+add entity";
        if (name !== "")
            commandLabel += " named " + name;

        this.$super(commandLabel);
        this.scenePtr = scenePtr;
        this.components = components;
        this.name = name;
        this.replicated = replicated;
        this.temporary = temporary;
        this.id = 0;
    },

    exec : function()
    {
        var entityPtr = this.scenePtr.createEntity(this.id, this.components, null, this.replicated, null, this.temporary);
        this.id = entityPtr.id;

        if (this.name !== "")
            entityPtr.setName(this.name);
    },

    undo : function()
    {
        this.scenePtr.removeEntity(this.id);
    }
});

var RemoveEntityCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, entityPtr)
    {
        var commandLabel = "-remove entity with ID " + entityPtr.id;
        if (entityPtr.getName() !== "")
            commandLabel += " named " + entityPtr.getName();

        this.$super(commandLabel);
        this.scenePtr = scenePtr;
        this.id = entityPtr.id;
        this.entityStr = "";
    },

    exec : function()
    {
        var entityPtr = this.scenePtr.entityById(this.id);
        if (isNotNull)
        {
            this.entityStr = entityPtr.serialize();
            this.scenePtr.removeEntity(this.id);
        }
    },

    undo : function()
    {
        this.scenePtr.deserializeFrom(this.entityStr);
    }
});

var AddComponentCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, entityId, compType, compName, isLocal, temporary)
    {
        if (isNull(compName))
            compName = "";
        if (isNull(isLocal))
            isLocal = false;
        if (isNull(temporary))
            temporary = false;

        var commandLabel = "+add component " + compType;
        if (compName !== "")
            commandLabel += " named " + compName;

        this.$super(commandLabel);

        this.scenePtr = scenePtr;
        this.entityId = entityId;
        this.compName = compName;
        this.compType = compType;
        this.isLocal = isLocal;
        this.temporary = temporary;
        this.compId = -1;
    },

    exec : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var componentPtr = entityPtr.createComponent(this.compType, this.compName, this.isLocal);
        if (isNotNull(componentPtr))
        {
            this.compId = componentPtr.id;
            componentPtr.setTemporary(this.temporary);
        }
    },

    undo : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        entityPtr.removeComponent(this.compId);
    }
});

var RemoveComponentCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, componentPtr)
    {
        var commandLabel = "-remove component of type " + componentPtr.typeName;
        if (componentPtr.getName() !== "")
            commandLabel += " named " + componentPtr.getName();

        this.$super(commandLabel);
        this.scenePtr = scenePtr;
        this.entityId = componentPtr.parentId();
        this.compStr = "";
        this.compId = componentPtr.id;
    },

    exec : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId)
        if (isNull(entityPtr))
            return;

        var componentPtr = entityPtr.componentById(this.compId);
        if (isNull(componentPtr))
            return;

        this.compStr = componentPtr.serialize();
        entityPtr.removeComponent(this.compId);
    },

    undo : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId)
        if (isNull(entityPtr))
            return;

        var component = JSON.parse(this.compStr);
        var componentPtr = entityPtr.createComponent(component.type, component.name);
        if (isNotNull(componentPtr))
        {
            this.compId = componentPtr.id;
            componentPtr.deserialize(component);
        }
    }
});

var AddAttributeCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, componentPtr, attributeName, attributeTypeId)
    {
        this.$super("+add attribute named " + attributeName + " of type " + attributeTypeId);
        this.scenePtr = scenePtr;
        this.entityId = componentPtr.parentId();
        this.compName = componentPtr.name;
        this.compType = componentPtr.typeName;
        this.attributeName = attributeName;
        this.attributeTypeId = attributeTypeId;
        this.index = -1;
    },

    exec : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var componentPtr = entityPtr.getComponent(this.compType, this.compName);
        if (isNull(componentPtr))
            return;

        componentPtr.createAttribute(this.attributeTypeId, this.attributeName);
        var attributePtr = componentPtr.attributeByName(this.attributeName);
        this.index = attributePtr.index;
    },

    undo : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var componentPtr = entityPtr.getComponent(this.compType, this.compName);
        if (isNull(componentPtr))
            return;

        componentPtr.removeAttribute(this.index);
    }
});

var RemoveAttributeCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, attributePtr)
    {
        this.$super("-remove attribute named " + attributePtr.name + " of type " + attributePtr.typeId);
        this.scenePtr = scenePtr;
        this.entityId = attributePtr.owner.parentId();
        this.compName = attributePtr.owner.name;
        this.compType = attributePtr.owner.typeName;
        this.attributeTypeId = attributePtr.typeId;
        this.attributeName = attributePtr.name;
        this.attributeIndex = attributePtr.index;
        this.value = attributePtr.get();
    },

    exec : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var componentPtr = entityPtr.getComponent(this.compType, this.compName);
        if (isNull(componentPtr))
            return;

        var attributePtr = componentPtr.getAttributeByIndex(this.attributeIndex);
        if (isNull(attributePtr))
            return;

        this.value = attributePtr.get();
        componentPtr.removeAttribute(attributePtr.index);

    },

    undo : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var componentPtr = entityPtr.getComponent(this.compType, this.compName);
        if (isNull(componentPtr))
            return;

        var success = componentPtr.createAttribute(this.attributeTypeId, this.attributeName);
        if (success)
        {
            var attributePtr = componentPtr.attributeByName(this.attributeName);
            attributePtr.set(this.value);
        }
    }
});

var AttributeChangeCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, attributePtr, value)
    {
        this.$super("*edit " + attributePtr.name);

        this.scenePtr = scenePtr;
        this.oldValue = attributePtr.get();
        this.newValue = value;
        this.name = attributePtr.name;
        this.index = attributePtr.index;
        this.typeId = attributePtr.typeId;

        this.compName = attributePtr.owner.name;
        this.compType = attributePtr.owner.typeName;
        this.entityId = attributePtr.owner.parentId();
    },

    set : function(value)
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var compPtr = entityPtr.getComponent(this.compType, this.compName);
        if (isNull(compPtr))
            return;

        var attrPtr = compPtr.getAttributeByIndex(this.index);
        if (isNull(attrPtr))
            return;

        attrPtr.set(value);
    },

    exec : function()
    {
        this.set(this.newValue);
    },

    undo : function()
    {
        this.set(this.oldValue);
    },
});

var PropertyChangeCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, componentPtr, path, type, value)
    {
        this.$super("* property change");
        this.scenePtr = scenePtr;
        this.entityId = componentPtr.parentId();
        this.compId = componentPtr.id;
        this.path = path.split(".");
        this.type = type;
        this.newValue = value;
    },

    setProperty: function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var compPtr = entityPtr.componentById(this.compId);
        if (isNull(compPtr))
            return;

        var i = 0;
        var property = compPtr._ptr.properties;
        for (i = 0; i < this.path.length - 1; ++i)
            property = property[this.path[i]];

        this.oldValue = property[this.path[i]];

        switch(this.type)
        {
            case "number":
            {
                property[this.path[i]] = parseFloat(this.newValue);
                break;
            }
            case "boolean":
            {
                property[this.path[i]] = (this.newValue === "true");
                break;
            }
            default:
            {
                property[this.path[i]] = this.newValue;
                break;
            }
        }
    },

    unsetProperty: function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var compPtr = entityPtr.componentById(this.compId);
        if (isNull(compPtr))
            return;

        var i = 0;
        var property = compPtr._ptr.properties;
        for (i = 0; i < this.path.length - 1; ++i)
            property = property[this.path[i]];

        property[this.path[i]] = this.oldValue;
    },

    exec: function()
    {
        this.setProperty();
    },

    undo: function()
    {
        this.unsetProperty();
    }
});

var MultiTransformCommand = ICommand.$extend(
{
    __init__ : function(states)
    {
        this.$super("* transform " + states.length + " entity(s)");
        this.states = [];
        for (var i = states.length - 1; i >= 0; i--)
        {
            this.states.push({
                id : states[i].target.parentEntity.id,
                before: states[i].before,
                after: states[i].after
            });
        }
    },

    exec : function()
    {
        for (var i = this.states.length - 1; i >= 0; i--)
        {
            var id = this.states[i].id;
            var entity = Tundra.scene.entityById(id);
            if (entity && entity.placeable)
                entity.placeable.transform = this.states[i].after;
        }
    },

    undo : function()
    {
        for (var i = this.states.length - 1; i >= 0; i--)
        {
            var id = this.states[i].id;
            var entity = Tundra.scene.entityById(id);
            if (entity && entity.placeable)
                entity.placeable.transform = this.states[i].before;
        }
    }
});

var CreatePrimitiveCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, primitiveType, meshRef)
    {
        this.$super("+add " + primitiveType);
        this.scenePtr = scenePtr;
        this.type = primitiveType;
        this.ref = meshRef;
        this.id = 0;
        this.pos = undefined;
    },

    exec : function()
    {
        var entity = this.scenePtr.createEntity(this.id, ["EC_Name", "EC_Placeable", "EC_Mesh"]);
        if (isNull(entity))
            return;

        this.id = entity.id;
        entity.setName(this.type);

        var meshComp = entity.getComponent("Mesh");
        if (isNull(meshComp))
            return;

        var meshRefAttr = meshComp.attributeByName("meshRef");
        if (isNull(meshRefAttr))
            return;

        meshRefAttr.set(this.ref);

        if (!this.pos)
        {
            this.pos = new THREE.Vector3(0,-2,-7);
            var camera = Tundra.renderer.activeCameraEntity();
            var cameraPos = camera.placeable.worldPosition();
            this.pos.applyQuaternion(camera.placeable.worldOrientation());
            this.pos.add(cameraPos);
        }

        entity._ptr.placeable.setPosition(this.pos);
    },

    undo : function()
    {
        this.scenePtr.removeEntity(this.id);
    }
});

var TransformCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, placeable, mode, oldValue, newValue)
    {
        this.$super("*" + mode + " entity, ID:" + placeable.parentEntity.id);

        this.scenePtr = scenePtr;
        this.mode = mode;
        this.entityId = placeable.parentEntity.id;
        this.compName = placeable.name;
        this.compType = "EC_Placeable";
        this.oldValue = oldValue;
        this.newValue = newValue;
    },

    set : function(value)
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var compPtr = entityPtr.getComponent(this.compType, this.compName);
        if (isNull(compPtr))
            return;

        var transform = compPtr.attribute("transform").getClone();
        if (this.mode === "translate")
            transform.setPosition(value);
        else if (this.mode === "rotate")
            transform.setRotation(value);
        else if (this.mode === "scale")
            transform.setScale(value);

        compPtr.attribute("transform").set(transform);
    },

    exec : function()
    {
        this.set(this.newValue);
    },

    undo : function()
    {
        this.set(this.oldValue);
    }
});

var PasteCommand = ICommand.$extend(
{
    __init__: function(objects)
    {
        this.$super("+Paste " + objects.length + (objects.length > 1 ? " entity" : " entities"));
        this.objects = objects;
        this.pasted = [];
    },

    exec: function()
    {
        if (this.objects.length > 0)
        {
            for (var i = 0; i < this.objects.length; ++i)
            {
                var object = this.objects[i];
                var entity = Tundra.scene.createEntity(0);
                entity.sync = object.sync;
                entity.temp = object.temp;
                entity.deserializeFromObject(object);

                this.pasted.push(entity.serializeToObject(true));
            }

            this.objects.length = 0;
        }
        else if (this.pasted.length > 0)
        {
            for (var i = 0; i < this.pasted.length; ++i)
            {
                var object = this.pasted[i];
                var entity = Tundra.scene.createEntity(object.id);
                entity.sync = object.sync;
                entity.temp = object.temp;
                entity.deserializeFromObject(object);
            }
        }
    },

    undo: function()
    {
        for (var i = 0; i < this.pasted.length; ++i)
            Tundra.scene.removeEntity(this.pasted[i].id);
    }
});

var MassAddComponentCommand = ICommand.$extend(
{
    __init__ : function(targetEntities, compType, compName, isLocal, temporary)
    {
        this.$super("+add " + compType + " to " + targetEntities.length + (targetEntities.length > 1 ? " entities" : " entity"));

        if (isNull(compName))
            compName = "";
        if (isNull(isLocal))
            isLocal = false;
        if (isNull(temporary))
            temporary = false;

        var commandLabel = "+add components " + compType;
        if (compName !== "")
            commandLabel += " named " + compName;
        commandLabel += " to " + targetEntities.length + (targetEntities.length > 1 ? " entities" : " entity");

        this.$super(commandLabel);

        this.targets = targetEntities;
        this.compName = compName;
        this.compType = compType;
        this.isLocal = isLocal;
        this.temporary = temporary;
        this.compIds = {};
    },

    exec: function()
    {
        for (var i = 0; i < this.targets.length; ++i)
        {
            var entityId = parseInt(this.targets[i]);
            var entity = Tundra.scene.entityById(entityId);
            if (entity)
            {
                var comp = null;
                if (!this.isLocal)
                    comp = entity.createComponent(this.compType, this.compName);
                else
                    comp = entity.createLocalComponent(this.compType, this.compName);
                if (comp)
                {
                    comp.temporary = this.temporary;
                    this.compIds[entityId] = comp.id;
                }
            }
        }
    },

    undo: function()
    {
        var keys = Object.keys(this.compIds);
        for (var i = 0; i < keys.length; ++i)
        {
            var entId = parseInt(keys[i]);
            var compId = this.compIds[entId];
            var entity = Tundra.scene.entityById(entId);
            if (entity)
                entity.removeComponent(compId);
        }

        this.compIds = {};
    }
});

var MassRemoveComponentCommand = ICommand.$extend(
{
    __init__ : function(targetEntities, compType)
    {
        this.$super("-remove " + compType + " from " + targetEntities.length + (targetEntities.length > 1 ? " entities" : " entity"));
        this.targets = targetEntities;
        this.type = compType;
        this.targetToComponents = {};
    },

    exec: function()
    {
        for (var i = 0; i < this.targets.length; ++i)
        {
            var entityId = parseInt(this.targets[i]);
            if (this.targetToComponents[entityId])
                continue;

            var entity = Tundra.scene.entityById(entityId);
            if (entity)
            {
                var comps = entity.getComponents(this.type);
                if (comps.length < 1)
                    continue;

                this.targetToComponents[entityId] = [];
                for (var j = 0; j < comps.length; ++j)
                {
                    this.targetToComponents[entityId].push(comps[j].serializeToObject(true));
                    entity.removeComponent(comps[j].id);
                }
            }
        }

        if ($("#componentListItem-" + this.type).length > 0)
            $("#componentListItem-" + this.type).hide();
    },

    undo: function()
    {
        var keys = Object.keys(this.targetToComponents);
        for (var i = 0; i < keys.length; ++i)
        {
            var key = keys[i];
            var entity = Tundra.scene.entityById(parseInt(key));
            if (entity)
            {
                for (var j = 0; j < this.targetToComponents[key].length; ++j)
                {
                    var comp = this.targetToComponents[key][j];
                    var compPtr = null;
                    if (comp.sync)
                        compPtr = entity.createComponent(comp.typeName, comp.name);
                    else
                        compPtr = entity.createLocalComponent(comp.typeName, comp.name);
                    compPtr.temporary = comp.temp;
                    compPtr.deserializeFromObject(comp);
                }
            }
        }

        this.targetToComponents = {};

        if ($("#componentListItem-" + this.type).length > 0)
            $("#componentListItem-" + this.type).show();
    }
});

var TundraKeyEvent = KeyEventWrapper.$extend(
{
    __init__ : function(keyEvent)
    {
        this.$super(-1);

        this.type = keyEvent.type;

        this.keyCode = keyEvent.keyCode;
        this.key = keyEvent.key;
        this.repeat = keyEvent.repeat;
        this.pressed = keyEvent.pressed;
        this.originalEvent = keyEvent.originalEvent.originalEvent;
    }
});

var TundraMouseEvent = MouseEventWrapper.$extend(
{
    __init__ : function(mouseEvent)
    {
        this.$super(-1);

        this.type = mouseEvent.type;
        this.x = mouseEvent.x;
        this.y = mouseEvent.y;

        this.relativeX = mouseEvent.relativeX;
        this.relativeY = mouseEvent.relativeY;
        this.relativeZ = mouseEvent.relativeZ;

        this.leftDown = mouseEvent.leftDown;
        this.middleDown = mouseEvent.middleDown;
        this.rightDown = mouseEvent.rightDown;

        this.targetId = mouseEvent.targetId;
        this.targetNodeName = mouseEvent.targetNodeName;
        this.originalEvent = mouseEvent.originalEvent;
        this.shiftPressed = Tundra.input.keyboard.pressed["shift"];
    }
});

var TundraScene = SceneWrapper.$extend(
{
    __init__ : function()
    {
        this.$super();
    },

    entities : function()
    {
        var result = [];
        var entities = Tundra.scene.entities;
        for (var i = 0; i < entities.length; i++)
            if (isNotNull(entities[i]))
                result.push(__(TundraEntity, entities[i]));

        return result;
    },

    entityById : function(entityId)
    {
        var entityPtr = Tundra.scene.entityById(entityId);
        if (entityPtr !== null && entityPtr !== undefined)
            return __(TundraEntity, entityPtr);

        return null;
    },

    entityByName: function(entityName)
    {
        var entityPtr = Tundra.scene.entityByName(entityName);
        if (entityPtr !== null && entityPtr !== undefined)
            return __(TundraEntity, entityPtr);

        return null;
    },

    createEntity : function(id, components, change, replicated, componentsReplicated, temporary)
    {
        temporary = temporary || false;
        if (isNull(replicated))
            replicated = true;
        if (isNull(componentsReplicated))
            componentsReplicated = replicated;
        if (isNotNull(replicated) && isNull(change))
            change = replicated ? AttributeChange.Replicated : AttributeChange.LocalOnly;
        if (isNull(id) || id == 0)
        {
            if (replicated)
                id = Tundra.scene.nextFreeId();
            else
                id = Tundra.scene.nextFreeIdLocal();
        }

        var entity = Tundra.scene.createEntity(id, components, change, replicated, componentsReplicated);
        entity.temporary = temporary;
        return __(TundraEntity, entity);
    },

    removeEntity : function(entityId)
    {
        Tundra.scene.removeEntity(entityId);
    },

    deserializeFrom : function(str)
    {
        var entity = JSON.parse(str);
        var entityPtr = this.entityById(entity.id);
        if (isNull(entityPtr))
            entityPtr = this.createEntity(entity.id, [], null, !entity.local);

        if (isNotNull(entityPtr))
            entityPtr.deserialize(entity);
    },

    registeredComponents : function()
    {
        return Scene.registeredComponentsList();
    },

    doesAllowSameNamedComponents : function()
    {
        return false;
    },

    componentNameWithPrefix : function(componentName)
    {
        return IComponent.ensureComponentNamePrefix(componentName);
    },

    componentNameInHumanFormat : function(typeName)
    {
        if (typeName.indexOf("EC_") == 0)
        {
            var compNameNoEC = typeName.substring(3);
            if (compNameNoEC == "DynamicComponent")
                compNameNoEC = "Dynamic";

            return compNameNoEC;
        }
        else
            return typeName;
    },

    doRaycast : function(x, y, selectionLayer)
    {
        var result = Tundra.renderer.raycast(x, y, selectionLayer);
        return new TundraRaycastResult(result);
    },

    isAttributeAtomic : function(attrTypeId)
    {
        return (attrTypeId === Attribute.String ||
                attrTypeId === Attribute.Int ||
                attrTypeId === Attribute.Real ||
                attrTypeId === Attribute.Bool ||
                attrTypeId === Attribute.UInt ||
                attrTypeId === Attribute.AssetReference ||
                attrTypeId === Attribute.EntityReference ||
                attrTypeId === Attribute.QVariant);
    },

    isAttributeBool : function(attrTypeId)
    {
        return (attrTypeId === Attribute.Bool);
    },

    /// AssetReferenceList and QVariantList technically are arrays
    isAttributeArray : function(attrTypeId)
    {
        return (attrTypeId === Attribute.AssetReferenceList ||
                attrTypeId === Attribute.QVariantList);
    },

    /// Transform is the most complex attribute we have
    isAttributeTransform : function(attrTypeId)
    {
        return (attrTypeId === Attribute.Transform);
    },

    isAttributeColor : function(attrTypeId)
    {
        return (attrTypeId === Attribute.Color);
    },

    /// Color/QPoint/Float2, Float3, Float4/Quat are tuples
    /// returns number of elements in the tuple, or 0 if not tuple
    isAttributeTuple : function(attrTypeId)
    {
        if (attrTypeId === Attribute.Color ||
           attrTypeId === Attribute.Float4 ||
           attrTypeId === Attribute.Quat)
            return 4;
        else if (attrTypeId === Attribute.Float3)
            return 3;
        else if (attrTypeId === Attribute.Float2 ||
                attrTypeId === Attribute.QPoint)
            return 2;
        else
            return 0;
    },

    // Returns a type name for a given type ID
    attributeTypeToName : function(attrTypeId)
    {
        return Attribute.toTypeName(attrTypeId);
    },

    attributeTypeIds : function()
    {
        return Attribute.typeIds();
    },

    reset : function()
    {
        Tundra.scene.reset();
    },

    unsubscribe : function(subscription)
    {
        Tundra.events.unsubscribe(subscription);
    },

    entityCreated : function(context, callback)
    {
        this.registerCallback("onEntityCreated", context, callback);
        return Tundra.scene.onEntityCreated(this, this._onEntityCreated);
    },

    entityRemoved : function(context, callback)
    {
        this.registerCallback("onEntityRemoved", context, callback);
        return Tundra.scene.onEntityRemoved(this, this._onEntityRemoved);
    },

    componentCreated : function(context, callback)
    {
        this.registerCallback("onComponentCreated", context, callback);
        return Tundra.scene.onComponentCreated(this, this._onComponentCreated);
    },

    componentRemoved : function(context, callback)
    {
        this.registerCallback("onComponentRemoved", context, callback);
        return Tundra.scene.onComponentRemoved(this, this._onComponentRemoved);
    },

    attributeChanged : function(context, callback)
    {
        this.registerCallback("onAttributeChanged", context, callback);
        return Tundra.scene.onAttributeChanged(this, this._onAttributeChanged);
    },

    sceneReset : function(context, callback)
    {
        this.registerCallback("onSceneReset", context, callback);
        return Tundra.scene.onReset(this, this._onSceneReset);
    },

    _onEntityCreated : function(entityPtr)
    {
        var entity = __(TundraEntity, entityPtr);
        this.callback("onEntityCreated", entity);


        setTimeout(function()
        {
            if (entityPtr.sky)
                IEditor.Instance.introManager.playSection("addContent2");
            else if (entityPtr.name === "Cube")
                IEditor.Instance.introManager.playSection("addContent3");
            else if (entityPtr.name === "movable")
                IEditor.Instance.introManager.playSection("addContent4");
        }, 1000);
    },

    _onEntityRemoved : function(entityPtr)
    {
        var entity = __(TundraEntity, entityPtr);
        this.callback("onEntityRemoved", entity);
        if (IEditor.Instance.transformEditor)
        {
            for (var i = IEditor.Instance.transformEditor.targets.length - 1; i >= 0; i--) {
                var target = IEditor.Instance.transformEditor.targets[i].parentEntity;
                if (target.id == entity.id)
                {
                    IEditor.Instance.transformEditor.clearSelection();
                    break;
                }
            };
        }
    },

    _onComponentCreated : function(entityPtr, componentPtr)
    {
        var entity = __(TundraEntity, entityPtr);
        var component = __(TundraComponent, componentPtr);

        this.callback("onComponentCreated", entity, component);

        if (entity.name === "movable" && component.typeName === "Light")
            IEditor.Instance.introManager.playSection("addContent7");
    },

    _onComponentRemoved : function(entityPtr, componentPtr)
    {
        var entity = __(TundraEntity, entityPtr);
        var component = __(TundraComponent, componentPtr);

        this.callback("onComponentRemoved", entity, component);

        if (IEditor.Instance.transformEditor)
        {
            for (var i = IEditor.Instance.transformEditor.targets.length - 1; i >= 0; i--) {
                var targetComp = IEditor.Instance.transformEditor.targets[i];
                var target = IEditor.Instance.transformEditor.targets[i].parentEntity;
                if (target.id == entity.id && targetComp.id == componentPtr.id)
                {
                    IEditor.Instance.transformEditor.clearSelection();
                    break;
                }
            };
        }
    },

    _onAttributeChanged : function(entityPtr, componentPtr, attributeIndex, attributeName, attributeValue)
    {
        var entity = __(TundraEntity, entityPtr);
        var component = __(TundraComponent, componentPtr);

        this.callback("onAttributeChanged", entity, component, attributeIndex, attributeName, attributeValue);
    },

    _onSceneReset : function()
    {
        this.callback("onSceneReset");
    },

    logInfo : function(text)
    {
        Tundra.client.logInfo("[Editor]: " + text);
    },

    logWarning : function(text)
    {
        Tundra.client.logWarning("[Editor]: " + text);
    },

    logError : function(text)
    {
        Tundra.client.logError("[Editor]: " + text);
    }
});

var TundraEntity = EntityWrapper.$extend(
{
    __init__ : function(entityPtr)
    {
        this.$super(entityPtr.id, entityPtr.name, entityPtr.local, entityPtr.temporary);
        this._ptr = entityPtr;

        this.callbacks = {};

        // entityPtr.InterfaceDesignerWrapper = this;
    },

    setName : function(name)
    {
        if (this.expired())
            return;

        this.name = name;
        this._ptr.setName(name);
    },

    getName : function()
    {
        return this._ptr.getName();
    },

    components : function()
    {
        var result = [];
        if (this.expired())
            return result;

        for (var i = 0; i < this._ptr.components.length; i++)
        {
            var componentPtr = this._ptr.components[i];
            result.push(__(TundraComponent, componentPtr));
        }

        return result;
    },

    createComponent : function(typeName, name, isLocal)
    {
        if (this.expired())
            return null;

        var attrChange = isLocal ? AttributeChange.LocalOnly : AttributeChange.Replicated;
        var componentPtr = this._ptr.createComponent(typeName, name, attrChange);
        if (isNotNull(componentPtr))
            return __(TundraComponent, componentPtr);

        return null;
    },

    hasComponent : function(type, name)
    {
        return isNotNull(this.getComponent(type, name));
    },

    getComponent : function(type, name)
    {
        if (this.expired())
            return null;

        var componentPtr = this._ptr.getComponent(type, name);
        if (componentPtr !== null && componentPtr !== undefined)
            return __(TundraComponent, componentPtr);

        return null;
    },

    componentById : function(componentId)
    {
        if (this.expired())
            return null;

        var componentPtr = this._ptr.getComponentById(componentId);
        if (componentPtr !== null && componentPtr !== undefined)
            return __(TundraComponent, componentPtr);

        return null;
    },

    removeComponent : function(componentId)
    {
        if (this.expired())
            return;

        this._ptr.removeComponent(componentId);
    },

    serialize : function()
    {
        var result = {};

        result.id = this.id;
        result.name = this.name;
        result.local = this.local;
        result.temporary = this.temporary;

        result.components = [];
        var comps = this.components();
        for (var i = 0; i < comps.length; i++)
            result.components.push(comps[i].serialize());

        return JSON.stringify(result);
    },

    deserialize : function(entity)
    {
        for (var i = 0; i < entity.components.length; i++)
        {
            var component = JSON.parse(entity.components[i]);
            var componentPtr = this.createComponent(component.type, component.name);
            if (isNotNull(componentPtr))
                componentPtr.deserialize(component);
        }
    },
});

var TundraComponent = ComponentWrapper.$extend(
{
    __init__ : function(componentPtr)
    {
        this.$super(componentPtr.id, componentPtr.name, componentPtr.typeName, componentPtr.parentEntity.id);
        this._ptr = componentPtr;

        this.callbacks = {};

        // componentPtr.InterfaceDesignerWrapper = this;
    },

    isDynamic : function()
    {
        if (this.expired())
            return false;

        return this._ptr.isDynamic();
    },

    setTemporary : function(temporary)
    {
        if (this.expired())
            return;

        this._ptr.temporary = temporary;
    },

    attributes : function()
    {
        var result = [];
        if (this.expired())
            return result;

        for (var i in this._ptr.attributes)
        {
            var attributePtr = this._ptr.attributes[i];
            if (isNotNull(attributePtr))
                result.push(__(TundraAttribute, attributePtr, this));
        }

        return result;
    },

    createAttribute : function(typeId, name)
    {
        if (this.expired())
            return null;

        return (this.isDynamic() && this._ptr.createAttribute(typeId, name, null, true));
    },

    attributeByName : function(name)
    {
        if (this.expired())
            return null;

        var attributePtr = this._ptr.attributes[name];
        if (isNotNull(attributePtr))
            return __(TundraAttribute, attributePtr, this);

        return null;
    },

    getAttributeByIndex : function(index)
    {
        if (this.expired())
            return null;

        return __(TundraAttribute, this._ptr.getAttributeByIndex(index), this);
    },

    removeAttribute : function(index)
    {
        if (this.expired())
            return false;

        return (this.isDynamic() && this._ptr.removeAttribute(index));
    },

    serialize : function()
    {
        var result = {};

        result.id = this.id;
        result.name = this.name;
        result.type = this.typeName;
        result.local = this.local;
        result.temporary = this.temporary;
        result.attributes = [];

        var attrs = this.attributes();
        for (var i = 0; i < attrs.length; i++)
            result.attributes.push(attrs[i].serialize());

        return JSON.stringify(result);
    },

    deserialize : function(component)
    {
        var attributes = component.attributes;
        for (var i = 0; i < attributes.length; i++)
        {
            var attr = JSON.parse(attributes[i]);
            var attrPtr = null;
            if (this.isDynamic())
            {
                var success = this.createAttribute(attr.typeId, attr.name);
                if (success)
                    attrPtr = this.attributeByName(attr.name);
            }
            else
                attrPtr = this.getAttributeByIndex(attr.index);

            if (isNotNull(attrPtr))
                attrPtr.deserialize(attr);
        }
    },

    onAttributeAdded : function(context, callback)
    {
        if (this.expired())
            return;

        if (!this.isDynamic())
            return;

        this.registerCallback("onAttributeAdded", context, callback);
        return this._ptr.onAttributeAdded(this, this._onAttributeAdded);
    },

    onAttributeAboutToBeRemoved : function(context, callback)
    {
        if (this.expired())
            return;

        if (!this.isDynamic())
            return;

        this.registerCallback("onAttributeAboutToBeRemoved", context, callback);
        return this._ptr.onAttributeAboutToBeRemoved(this, this._onAttributeAboutToBeRemoved);
    },

    _onAttributeAdded : function(component, attribute)
    {
        var componentPtr = __(TundraComponent, component);
        var attributePtr = __(TundraAttribute, attribute, componentPtr);

        this.callback("onAttributeAdded", componentPtr, attributePtr);
    },

    _onAttributeAboutToBeRemoved : function(component, attributeIndex, attributeName)
    {
        var componentPtr = __(TundraComponent, component);

        this.callback("onAttributeAboutToBeRemoved", componentPtr, attributeIndex, attributeName);
    }
});

var TundraAttribute = AttributeWrapper.$extend(
{
    __init__ : function(attributePtr, owner)
    {
        var parent = null;
        if (isNull(owner))
            parent = __(TundraComponent, attributePtr.owner);
        else
            parent = owner;

        this.$super(attributePtr.index, attributePtr.typeId, attributePtr.name, parent);
        this._ptr = attributePtr;

        // attributePtr.InterfaceDesignerWrapper = this;
    },

    get : function()
    {
        if (this.expired())
            return null;

        return this._ptr.getClone();
    },

    set : function(value)
    {
        if (this.expired())
            return;

        this._ptr.set(value);
    },

    serialize : function()
    {
        var result = {
            name : this.name,
            typeId : this.typeId,
            index : this.index
        };

        var value = this.get();
        if (this.typeId === Attribute.Transform)
            result.value = {
                pos : value.pos,
                rot : value.rot,
                scale : value.scale
            };
        else
            result.value = value;

        return JSON.stringify(result);
    },

    deserialize : function(attribute)
    {
        if (attribute.typeId === Attribute.Transform)
        {
            var attrValue = attribute.value;
            var pos = new THREE.Vector3(attrValue.pos.x, attrValue.pos.y, attrValue.pos.z);
            var rot = new THREE.Vector3(attrValue.rot.x, attrValue.rot.y, attrValue.rot.z);
            var scale = new THREE.Vector3(attrValue.scale.x, attrValue.scale.y, attrValue.scale.z);

            var transform = new Transform(pos, rot, scale);
            this.set(transform);
        }
        else
            this.set(attribute.value)
    }
});

var TundraRaycastResult = RaycastResultWrapper.$extend(
{
    __init__ : function(raycastResult)
    {
        this.$super();

        if (isNotNull(raycastResult.entity))
            this.entity = __(TundraEntity, raycastResult.entity);
        if (isNotNull(raycastResult.component))
            this.component = __(TundraComponent, raycastResult.component);

        this.pos = raycastResult.pos;
        this.distance = raycastResult.distance;
        this.submesh = raycastResult.submesh;
        this.faceIndex = raycastResult.faceIndex;
        this.ray = raycastResult.ray;
    }
});

var TundraEditor = IEditor.$extend(
{
    __classvars__ :
    {
        scene : null
    },

    __init__ : function(options)
    {
        this.$super(options);
        this.app = options.app || false;

        this.introManager._injectStyle(this.app.resolveRef("webtundra-applications://editor/lib/introjs.min.css"));
        var fancyTreeCssPath = this.app ? this.app.resolveRef("webtundra-applications://editor/lib/skin-win8/ui.fancytree.css") : ".application/editor/lib/skin-win8/ui.fancytree.css";
        $("head").append('<link rel="stylesheet" href="' + fancyTreeCssPath + '">');

        this.meshRefs = {
            "Ball" : "http://meshmoon.data.s3.amazonaws.com/asset-library/meshes/primitives/Sphere.mesh",
            "Cube" : "http://meshmoon.data.s3.amazonaws.com/asset-library/meshes/primitives/Cube.mesh",
            "Cone" : "http://meshmoon.data.s3.amazonaws.com/asset-library/meshes/primitives/Cone.mesh",
            "Cylinder" : "http://meshmoon.data.s3.amazonaws.com/asset-library/meshes/primitives/Cylinder.mesh"
        };

        this.axisHelper = new THREE.AxisHelper(100);
        this.gridHelper = new THREE.GridHelper(100,5);
        this.gridHelper.setColors(new THREE.Color(0xFF0000), new THREE.Color(0x000000));

        this.actions =
        {
/*
            placeable:
            [
                {
                    name: 'lookAt',
                    arguments: [
                        {
                            name: 'x',
                            type: 'number',
                            optional : false
                        },
                        {
                            name: 'y',
                            type: 'number',
                            optional : false
                        },
                        {
                            name: 'z',
                            type: 'number',
                            optional : false
                        }
                    ]
                }
            ],

            camera:
            [
                {
                    name: 'isPointInView',
                    arguments: [
                        {
                            name: 'x',
                            type: 'number',
                            optional : false
                        },
                        {
                            name: 'y',
                            type: 'number',
                            optional : false
                        },
                        {
                            name: 'z',
                            type: 'number',
                            optional : false
                        }
                    ],
                    returns: 'boolean'
                }
            ],
*/
            sound:
            [
                {
                    name: 'play'
                },
                {
                    name: 'stop'
                },
                {
                    name: 'pause'
                }
            ],

            animationcontroller:
            [
                {
                    name: 'getAvailableAnimations',
                    returns: 'Array'
                }
            ]
        };
    },

    /* virtual */
    defaultFontConfig : function()
    {
        return {
            "font-family"    : '"Roboto", sans-serif',
            "font-size"      : "14px",
            "text-transform" : "uppercase"
        };
    },

    /* virtual */
    defaultMonospaceFontConfig : function()
    {
        return {
            "font-family" : '"Source Code Pro", monospace'
        };
    },

    /* virtual */
    isConnected : function()
    {
        return Tundra.client.isConnected();
    },

    /* virtual */
    width : function()
    {
        return this.container().width();
    },

    /* virtual */
    height : function()
    {
        var containerHeight = this.container().height();
        var taskbarHeight = (this.taskbar() ? this.taskbar().height() : 0);
        return containerHeight - taskbarHeight;
    },

    taskbar : function()
    {
        return (Tundra.usingPolymer() && Tundra.ui.taskbar ? undefined : Tundra.ui.taskbar);
    },

    container : function()
    {
        return $("body");
    },

    canvasContainer: function()
    {
        return $("#webtundra-container-custom");
    },

    /* pure virtual */
    addWidget : function(element, type)
    {
        $("body").append(element);

        element._tundraType = type;
        if (!Array.isArray(this._tundraElements))
            this._tundraElements = [];
        this._tundraElements.push(element);
    },

    setEnabled : function(enabled)
    {
        this.$super(enabled);

        if (!Array.isArray(this._tundraElements))
            return;

        for (var i = 0; i < this._tundraElements.length; i++)
        {
            var element = this._tundraElements[i];
            if (element._tundraType === "top")
            {
                Tundra.container.css({
                    top    : (enabled ? element.outerHeight(true) : ""),
                    height : (enabled ? "calc(100% - " + element.outerHeight(true) + "px)" : "100%")
                });
            }
            else if (element._tundraType === "right")
            {
                Tundra.container.css({
                    width : (enabled ? "calc(100% - " + element.outerWidth(true) + "px)" : "100%")
                });
            }
        };

        Tundra.ui.onWindowResizeDOM();
        AsyncHelper.async(Tundra.ui.onWindowResizeDOM.bind(Tundra.ui));
    },

    /* pure virtual */
    registerClientConnectedCallback : function(context, callback)
    {
        Tundra.client.onConnected(context, callback);
    },

    /* pure virtual */
    registerKeyEventCallback : function(context, callback)
    {
        this.registerCallback("onKeyEvent", context, callback);
        Tundra.input.onKeyEvent(this, this.onKeyEvent, 1000);
    },

    /* pure virtual */
    registerMouseEventCallback : function(context, callback)
    {
        this.registerCallback("onMouseEvent", context, callback);
        Tundra.input.onMousePress(this, this.onMouseEvent, 1000);
        Tundra.input.onMouseRelease(this, this.onMouseEvent, 1000);
    },

    /* pure virtual */
    registerResizeEventCallback : function(context, callback)
    {
        this.registerCallback("onResizeEvent", context, callback);
        Tundra.ui.onWindowResize(this, this.onResizeEvent);
    },

    registerSceneObject : function()
    {
        TundraEditor.scene = new TundraScene();
        return TundraEditor.scene;
    },

    onKeyEvent : function(keyEvent)
    {
        var wrapper = new TundraKeyEvent(keyEvent);
        this.callback("onKeyEvent", wrapper);
        return (!wrapper.suppressed);
    },

    onMouseEvent : function(mouseEvent)
    {
        var wrapper = new TundraMouseEvent(mouseEvent);
        this.callback("onMouseEvent", wrapper);

        // @todo Fix this correctly by doing actions like selecting entity on "release" instead of "press"
        // this has to happen in InterfaceDesigner-main.js not here. But we need to provide it enough info
        // as in if left button was down on the previous "press".
        var suppressed = wrapper.suppressed;
        if (mouseEvent.type === "release")
        {
            suppressed = (this._lastMouseSuppressed === true);
            this._lastMouseSuppressed = false;
        }
        else
            this._lastMouseSuppressed = wrapper.suppressed;
        return (!wrapper.suppressed);
    },

    onResizeEvent : function(width, height)
    {
        var body = $("body");
        this.callback("onResizeEvent", body.width(), body.height());
    },

    initTransformEditor : function()
    {
        this.transformEditor = Tundra.Classes.PlaceableUtils.Gizmo;
        Tundra.events.subscribe("TransformEditor.MultiTransform", function(states) {
            this.multiTransformCommand(states);
        }.bind(this));
    },

    createPrimitive : function(type)
    {
        this.undoStack.pushAndExec(new CreatePrimitiveCommand(TundraEditor.scene, type, this.meshRefs[type]));
    },

    createMovable : function()
    {
        this.addEntityCommand(["EC_Placeable"], "movable", true);
    },

    createDrawable : function()
    {
        this.addEntityCommand(["EC_Placeable", "EC_Mesh"], "drawable", true);
    },

    createScript : function()
    {
        this.addEntityCommand(["EC_Script"], "script", true);
    },

    createLight: function()
    {
        this.addEntityCommand(["EC_Placeable", "EC_Light"], "light", true);
    },

    showGrid : function()
    {
        Tundra.renderer.scene.add(this.gridHelper);
    },

    hideGrid : function()
    {
        Tundra.renderer.scene.remove(this.gridHelper);
    },

    showAxes : function()
    {
        Tundra.renderer.scene.add(this.axisHelper);
    },

    hideAxes : function()
    {
        Tundra.renderer.scene.remove(this.axisHelper);
    },

    startIntro: function()
    {
        this.introManager.addSection(1, "introduction", [
            {
                intro : "Welcome to the Interface Designer demo! <br>In this example you will learn how to use the editor in WebTundra. This demo contains couple of sections that will show you how to create and manipulate content using the interface designer. Please follow the steps carefully."
            },
            {
                intro: "We are currently in an empty scene, with only blackness surrounding us. Press <code>" + this.toggleEditorShortcut  + "</code> to open the Interface Designer"
            }
        ]);

        this.introManager.addSection(2, "basics", [
            {
                intro: "The scene tree panel shows all existing entities as top-level items, and its components as the children. Double-clicking on an entity or component opens that entity in the <b>EC editor</b>.",
                element: "#scenetree-panel",
                position: "left"
            },
            {
                intro: "You can undo, redo, save, load, create primitives, quickly add entities etc. from the toolbar.",
                element: "#interfaceDesigner-toolbar",
                position: "bottom"
            },
            {
                intro: "We are going to start adding some content into the scene. Click here to open the <b>Add new entity</b> dialog.",
                element: "#st-add-entity-button"
            },
        ]);

        this.introManager.addSection(3, "addContent1", [
            {
                intro: "Let's add a sky to the scene. Drag the <code>Sky</code> component into the designated space below and click on <b>Add entity</b>. You can name the entity if you like, or also make it local (meaning it won't be sent to the network)",
                element: "#dialog-AddEntity",
                position: "top"
            },
        ]);

        this.introManager.addSection(4, "addContent2", [
            {
                intro: "Now your scene contains a sky box. We will proceed adding some more content in the scene."
            },
            {
                intro: "You can add some ready-made primitive shapes. For example, select <b>Cube</b> from this menu.",
                element: "#_toolkit-createButton"
            }
        ]);

        this.introManager.addSection(5, "addContent3", [
            {
                intro: "A cube has been created into the scene. You can move around with the camera using <b>WSAD</b> or the arrow keys, and right-click drag to rotate the camera. For the next step, click on the cube you just created."
            }
        ]);

        this.introManager.addSection(6, "ecEditor", [
            {
                intro: "This is the <b>entity-component editor</b>. It is automatically shown when you select an entity from the scene, or from the scene tree. You can see and edit the components this cube contains: <code>Name</code>, <code>Placeable</code> and <code>Mesh</code>",
                element: "#eceditor-panel",
                position: "left"
            },
            {
                intro: "The entity unique ID shown in brackets and the entity name shown here",
                element: "#editor-entity-label",
                position: "left"
            },
            {
                intro: "You can add new components to the selected entity...",
                element: "#ec-add-component-button",
                position: "left"
            },
            {
                intro: "...expand or collapse the components...",
                element: "#ec-expand-collapse-button",
                position: "left"
            },
            {
                intro: "... or 'unlock' editing of the components, for example if you want to remove a component from the entity.",
                element: "#ec-edit-component-button",
                position: "left"
            },
            {
                intro: "These are the components that this entity has. Clicking on the titles will expand their contents where you can further change their attributes.",
                element: "#editor-component-accordions",
                position: "left"
            },
            {
                intro: "Clicking here will remove the selected entity",
                element: "#_toolkit-deleteButton",
                position: "bottom"
            },
            {
                intro: "Switch between the scene tree editor and EC editor here",
                element: "#_toolkit-panelsButtonSet",
                position: "bottom"
            },
            {
                intro: "Additionally, if the entity contains a <code>Placeable</code> component, a <b>transform gizmo</b> will be shown at its origin point (typically the center). You can drag the gizmo by one of the axis to move the cube around. Drag the planes to lock the movement on a plane (moving on two axes at the same time)",
                position: "top"
            },
            {
                intro: "You can change the transform gizmo's mode via these radio buttons. For example, select <b>rotate</b> if you want to rotate the cube, <b>scale</b> to scale it, etc.",
                element: "#_toolkit-transformButtonSet",
                position: "bottom"
            },
            {
                intro: "Let's add some light into the scene. A light entity requires the components <code>Placeable</code> and <code>Light</code>. Via this menu you can quickly add most commonly defined entities here. 'Movable' will create an entity with the <code>Placeable</code> component, 'Drawable' with <code>Placeable</code> and <code>Mesh</code>, 'Script' with <code>Script</code> component, etc. First, click on the <b>Add...</b> button, and select <b>Movable</b> from the menu.",
                element: "#_toolkit-quickAddButton",
                position: "bottom"
            }
        ]);

        this.introManager.addSection(7, "addContent4", [
            {
                intro: "A 'movable' entity has been created. Now switch to the scene editor if you haven't already so...",
                element: "#_toolkit-panelsButtonSet",
            },
            {
                intro: "... and double-click 'movable' from the scene tree",
                element: "#_toolkit-panelsButtonSet"
            }
        ]);

        this.introManager.addSection(8, "ecEditor2", [
            {
                intro: "Next, click here to open the <b>Add new component</b> dialog",
                element: "#ec-add-component-button",
                position: "left"
            }
        ]);

        this.introManager.addSection(9, "addContent6", [
            {
                intro: "One step away from adding a 'light' functionality to this entity. Select <code>Light</code> from the drop-down menu. Additionally, you can define this component as local, and / or temporary.",
                element: "#dialog-AddComponent",
                position: "top"
            }
        ]);

        this.introManager.addSection(10, "addContent7", [
            {
                intro: "Excellent. The cube should be illuminated now."
            },
            {
                intro: "WebTundra supports variety of mesh formats that you can import into the scene. Such meshes should be hosted as you choose, and the URL to the mesh file given to <code>meshRef</code> attribute of <code>Mesh</code> component."
            },
            {
                intro: "You can add such meshes as many as you want. For example, selecting <b>drawable</b> from this menu, will create an entity with 'Placeable' and 'Mesh' components.",
                element: "#_toolkit-quickAddButton",
                position: "bottom"
            },
            {
                intro: "You can then select the entity as you did before from the scene tree editor, and expand the Mesh component. You can then add the URL to your mesh file under <code>meshRef</code>. If the transfer is successful, you should see the mesh shortly after"
            },
            {
                intro: "That's it for this introduction! You can continue using the interface designer now."
            }
        ]);

        this.introManager.start("introduction");
    },

    hasActions: function(compTypeName)
    {
        return (!!this.actions[compTypeName.toLowerCase()]);
    },

    actionsForComponent: function(compTypeName)
    {
        if (this.hasActions(compTypeName))
            return this.actions[compTypeName.toLowerCase()];

        return undefined;
    },

    addEntityCommand : function(components, entityName, replicated, temporary)
    {
        temporary = temporary || false;
        this.undoStack.pushAndExec(new AddEntityCommand(TundraEditor.scene, components, entityName, replicated, temporary));
    },

    removeEntityCommand : function(entityPtr)
    {
        this.undoStack.pushAndExec(new RemoveEntityCommand(TundraEditor.scene, entityPtr));
    },

    addComponentCommand : function(entityId, compType, compName, isLocal, temporary)
    {
        this.undoStack.pushAndExec(new AddComponentCommand(TundraEditor.scene, entityId, compType, compName, isLocal, temporary));
    },

    massAddComponentCommand: function(targetEntities, compType, name, isLocal, temporary)
    {
        this.undoStack.pushAndExec(new MassAddComponentCommand(targetEntities, compType, name, isLocal, temporary));
    },

    removeComponentCommand : function(componentPtr)
    {
        this.undoStack.pushAndExec(new RemoveComponentCommand(TundraEditor.scene, componentPtr));
    },

    massRemoveComponentCommand: function(targetEntities, compType)
    {
        this.undoStack.pushAndExec(new MassRemoveComponentCommand(targetEntities, compType));
    },

    addAttributeCommand : function(componentPtr, attrTypeId, attrName)
    {
        var existing = componentPtr.attributeByName(attrName);
        if (isNotNull(existing))
            return false;

        this.undoStack.pushAndExec(new AddAttributeCommand(TundraEditor.scene, componentPtr, attrName, attrTypeId));
        return true;
    },

    removeAttributeCommand : function(attributePtr)
    {
        this.undoStack.pushAndExec(new RemoveAttributeCommand(TundraEditor.scene, attributePtr));
    },

    changeAttributeCommand : function(attributePtr, newValue)
    {
        this.undoStack.pushAndExec(new AttributeChangeCommand(TundraEditor.scene, attributePtr, newValue));
    },

    changePropertyCommand : function(component, path, type, value)
    {
        this.undoStack.pushAndExec(new PropertyChangeCommand(TundraEditor.scene, component, path, type, value));
    },

    multiTransformCommand : function(states)
    {
        this.undoStack.pushCommand(new MultiTransformCommand(states));
    },

    pasteCommand: function(clipboard)
    {
        if (!clipboard || clipboard.length < 1)
            return;

        this.undoStack.pushAndExec(new PasteCommand(clipboard));
    },

    save : function(filename)
    {
        var sceneTxml = Tundra.scene.serializeToXml();
        var sceneTxmlString = new XMLSerializer().serializeToString(sceneTxml);
        var blob = new Blob([vkbeautify.xml(sceneTxmlString)], {type: "text/xml;charset=utf-8"});
        saveAs(blob, filename + ".txml");
    },

    load : function(fileObject)
    {
        var reader = new FileReader();
        reader.addEventListener("loadend", function(e)
        {
            var txt = e.target.result;
            var parser = new DOMParser();
            var xmlDoc = parser.parseFromString(txt, "text/xml");
            Tundra.scene.deserializeFromXml(xmlDoc);
        });
        reader.readAsText(fileObject);
    },

    copy: function()
    {
        var entities = [];
        for (var i = 0; i < this.transformEditor.targets.length; ++i)
            entities.push(this.transformEditor.targets[i].parentEntity.serializeToObject(true));

        this.clipboard = entities;

        this.toolkit.showNotification(this.clipboard.length + " object(s) copied", 1000);
    }
});

// Main IApplication object
var EditorApplication = IApplication.$extend(
{
    __init__ : function()
    {
        this.$super("Editor");

        Tundra.events.subscribe("InterfaceDesigner.Toggle", function() {
            if (this.editor)
                this.editor.toggleEditor();
        }.bind(this));

        Tundra.events.subscribe("InterfaceDesigner.SetEnabled", function(enabled) {
            if (this.editor)
                this.editor.setEnabled(enabled === true);
        }.bind(this));

        Tundra.events.subscribe("InterfaceDesigner.Start", function(enabled) {
            this.start();
        }.bind(this));

        // Auto start in dev mode
        //if (Tundra.usingRequireJS())
            this.start();
    },

    start : function()
    {
        if (this.started === true || this.editor !== undefined)
            return;
        this.started = true;

        IApplication.loadDependencies(this,
            "lib/jquery.fancytree-all.min.js", "lib/FileSaver.min.js", "lib/vkbeautify.0.99.00.beta.js", "lib/jquery.ui-contextmenu.min.js", "lib/intro.js")
        .done(function()
        {
            this.editor = new TundraEditor({
                type: "webtundra",
                app : this
            });
            this.entity.temporary = true;
        }.bind(this));
    }
})

return EditorApplication;

});
