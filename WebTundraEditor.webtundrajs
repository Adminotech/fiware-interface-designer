define([
        "lib/classy",
        "lib/three",
        "core/framework/Tundra",
        "core/script/IApplication",
        "core/scene/Scene",
        "core/scene/IComponent",
        "core/scene/Attribute",
        "core/scene/AttributeChange",
        "core/math/Transform",
        "core/frame/AsyncHelper",
        "application/editor/InterfaceDesigner-main",
        "application/editor/lib/jquery.ui-contextmenu.min"
    ], function(Class, THREE, Tundra, IApplication, Scene, IComponent, Attribute, AttributeChange, Transform, AsyncHelper, _Editor, _jquicm) {

var AddEntityCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, components, name, replicated)
    {
        if (isNull(name))
            name = "";
        if (isNull(replicated))
            replicated = true;

        var commandLabel = "+add entity";
        if (name !== "")
            commandLabel += " named " + name;

        this.$super(commandLabel);
        this.scenePtr = scenePtr;
        this.components = components;
        this.name = name;
        this.replicated = replicated;
        this.id = 0;
    },

    exec : function()
    {
        var entityPtr = this.scenePtr.createEntity(this.id, this.components, null, this.replicated);
        this.id = entityPtr.id;

        if (this.name !== "")
            entityPtr.setName(this.name);
    },

    undo : function()
    {
        this.scenePtr.removeEntity(this.id);
    }
});

var RemoveEntityCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, entityPtr)
    {
        var commandLabel = "-remove entity with ID " + entityPtr.id;
        if (entityPtr.getName() !== "")
            commandLabel += " named " + entityPtr.getName();

        this.$super(commandLabel);
        this.scenePtr = scenePtr;
        this.id = entityPtr.id;
        this.entityStr = "";
    },

    exec : function()
    {
        var entityPtr = this.scenePtr.entityById(this.id);
        if (isNotNull)
        {
            this.entityStr = entityPtr.serialize();
            this.scenePtr.removeEntity(this.id);
        }
    },

    undo : function()
    {
        this.scenePtr.deserializeFrom(this.entityStr);
    }
});

var AddComponentCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, entityId, compType, compName, isLocal, temporary)
    {
        if (isNull(compName))
            compName = "";
        if (isNull(isLocal))
            isLocal = false;
        if (isNull(temporary))
            temporary = false;

        var commandLabel = "+add component of type " + compType;
        if (compName !== "")
            commandLabel += " named " + compName;

        this.$super(commandLabel);

        this.scenePtr = scenePtr;
        this.entityId = entityId;
        this.compName = compName;
        this.compType = compType;
        this.isLocal = isLocal;
        this.temporary = temporary;
        this.compId = -1;
    },

    exec : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var componentPtr = entityPtr.createComponent(this.compType, this.compName, this.isLocal);
        if (isNotNull(componentPtr))
        {
            this.compId = componentPtr.id;
            componentPtr.setTemporary(this.temporary);
        }
    },

    undo : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        entityPtr.removeComponent(this.compId);
    }
});

var RemoveComponentCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, componentPtr)
    {
        var commandLabel = "-remove component of type " + componentPtr.typeName;
        if (componentPtr.getName() !== "")
            commandLabel += " named " + componentPtr.getName();

        this.$super(commandLabel);
        this.scenePtr = scenePtr;
        this.entityId = componentPtr.parentId();
        this.compStr = "";
        this.compId = componentPtr.id;
    },

    exec : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId)
        if (isNull(entityPtr))
            return;

        var componentPtr = entityPtr.componentById(this.compId);
        if (isNull(componentPtr))
            return;

        this.compStr = componentPtr.serialize();
        entityPtr.removeComponent(this.compId);
    },

    undo : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId)
        if (isNull(entityPtr))
            return;

        var component = JSON.parse(this.compStr);
        var componentPtr = entityPtr.createComponent(component.type, component.name);
        if (isNotNull(componentPtr))
        {
            this.compId = componentPtr.id;
            componentPtr.deserialize(component);
        }
    }
});

var AddAttributeCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, componentPtr, attributeName, attributeTypeId)
    {
        this.$super("+add attribute named " + attributeName + " of type " + attributeTypeId);
        this.scenePtr = scenePtr;
        this.entityId = componentPtr.parentId();
        this.compName = componentPtr.name;
        this.compType = componentPtr.typeName;
        this.attributeName = attributeName;
        this.attributeTypeId = attributeTypeId;
        this.index = -1;
    },

    exec : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var componentPtr = entityPtr.getComponent(this.compType, this.compName);
        if (isNull(componentPtr))
            return;

        componentPtr.createAttribute(this.attributeTypeId, this.attributeName);
        var attributePtr = componentPtr.attributeByName(this.attributeName);
        this.index = attributePtr.index;
    },

    undo : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var componentPtr = entityPtr.getComponent(this.compType, this.compName);
        if (isNull(componentPtr))
            return;

        componentPtr.removeAttribute(this.index);
    }
});

var RemoveAttributeCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, attributePtr)
    {
        this.$super("-remove attribute named " + attributePtr.name + " of type " + attributePtr.typeId);
        this.scenePtr = scenePtr;
        this.entityId = attributePtr.owner.parentId();
        this.compName = attributePtr.owner.name;
        this.compType = attributePtr.owner.typeName;
        this.attributeTypeId = attributePtr.typeId;
        this.attributeName = attributePtr.name;
        this.attributeIndex = attributePtr.index;
        this.value = attributePtr.get();
    },

    exec : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var componentPtr = entityPtr.getComponent(this.compType, this.compName);
        if (isNull(componentPtr))
            return;

        var attributePtr = componentPtr.getAttributeByIndex(this.attributeIndex);
        if (isNull(attributePtr))
            return;

        this.value = attributePtr.get();
        componentPtr.removeAttribute(attributePtr.index);

    },

    undo : function()
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var componentPtr = entityPtr.getComponent(this.compType, this.compName);
        if (isNull(componentPtr))
            return;

        var success = componentPtr.createAttribute(this.attributeTypeId, this.attributeName);
        if (success)
        {
            var attributePtr = componentPtr.attributeByName(this.attributeName);
            attributePtr.set(this.value);
        }
    }
});

var AttributeChangeCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, attributePtr, value)
    {
        this.$super("*edit " + attributePtr.name);

        this.scenePtr = scenePtr;
        this.oldValue = attributePtr.get();
        this.newValue = value;
        this.name = attributePtr.name;
        this.index = attributePtr.index;
        this.typeId = attributePtr.typeId;

        this.compName = attributePtr.owner.name;
        this.compType = attributePtr.owner.typeName;
        this.entityId = attributePtr.owner.parentId();
    },

    set : function(value)
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var compPtr = entityPtr.getComponent(this.compType, this.compName);
        if (isNull(compPtr))
            return;

        var attrPtr = compPtr.getAttributeByIndex(this.index);
        if (isNull(attrPtr))
            return;

        attrPtr.set(value);
    },

    exec : function()
    {
        this.set(this.newValue);
    },

    undo : function()
    {
        this.set(this.oldValue);
    },
});

var MultiTransformCommand = ICommand.$extend(
{
    __init__ : function(states)
    {
        this.$super("* transform " + states.length + " entity(s)");
        this.states = [];
        for (var i = states.length - 1; i >= 0; i--)
        {
            this.states.push({
                id : states[i].target.parentEntity.id,
                before: states[i].before,
                after: states[i].after
            });
        }
    },

    exec : function()
    {
        for (var i = this.states.length - 1; i >= 0; i--)
        {
            var id = this.states[i].id;
            var entity = Tundra.scene.entityById(id);
            if (entity && entity.placeable)
                entity.placeable.transform = this.states[i].after;
        }
    },

    undo : function()
    {
        for (var i = this.states.length - 1; i >= 0; i--)
        {
            var id = this.states[i].id;
            var entity = Tundra.scene.entityById(id);
            if (entity && entity.placeable)
                entity.placeable.transform = this.states[i].before;
        }
    }
});

var CreatePrimitiveCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, primitiveType, meshRef)
    {
        this.$super("+add " + primitiveType);
        this.scenePtr = scenePtr;
        this.type = primitiveType;
        this.ref = meshRef;
        this.id = 0;
    },

    exec : function()
    {
        var entity = this.scenePtr.createEntity(this.id, ["EC_Name", "EC_Placeable", "EC_Mesh"]);
        if (isNull(entity))
            return;

        this.id = entity.id;
        entity.setName(this.type);

        var meshComp = entity.getComponent("Mesh");
        if (isNull(meshComp))
            return;

        var meshRefAttr = meshComp.attributeByName("meshRef");
        if (isNull(meshRefAttr))
            return;

        meshRefAttr.set(this.ref);
    },

    undo : function()
    {
        this.scenePtr.removeEntity(this.id);
    }
});

var TransformCommand = ICommand.$extend(
{
    __init__ : function(scenePtr, placeable, mode, oldValue, newValue)
    {
        this.$super("*" + mode + " entity, ID:" + placeable.parentEntity.id);

        this.scenePtr = scenePtr;
        this.mode = mode;
        this.entityId = placeable.parentEntity.id;
        this.compName = placeable.name;
        this.compType = "EC_Placeable";
        this.oldValue = oldValue;
        this.newValue = newValue;
    },

    set : function(value)
    {
        var entityPtr = this.scenePtr.entityById(this.entityId);
        if (isNull(entityPtr))
            return;

        var compPtr = entityPtr.getComponent(this.compType, this.compName);
        if (isNull(compPtr))
            return;

        var transform = compPtr.attribute("transform").getClone();
        if (this.mode === "translate")
            transform.setPosition(value);
        else if (this.mode === "rotate")
            transform.setRotation(value);
        else if (this.mode === "scale")
            transform.setScale(value);

        compPtr.attribute("transform").set(transform);
    },

    exec : function()
    {
        this.set(this.newValue);
    },

    undo : function()
    {
        this.set(this.oldValue);
    }
});

var TundraKeyEvent = KeyEventWrapper.$extend(
{
    __init__ : function(keyEvent)
    {
        this.$super(-1);

        this.type = keyEvent.type;

        this.keyCode = keyEvent.keyCode;
        this.key = keyEvent.key;
        this.repeat = keyEvent.repeat;
        this.pressed = keyEvent.pressed;
        this.originalEvent = keyEvent.originalEvent.originalEvent;
    }
});

var TundraMouseEvent = MouseEventWrapper.$extend(
{
    __init__ : function(mouseEvent)
    {
        this.$super(-1);

        this.type = mouseEvent.type;
        this.x = mouseEvent.x;
        this.y = mouseEvent.y;

        this.relativeX = mouseEvent.relativeX;
        this.relativeY = mouseEvent.relativeY;
        this.relativeZ = mouseEvent.relativeZ;

        this.leftDown = mouseEvent.leftDown;
        this.middleDown = mouseEvent.middleDown;
        this.rightDown = mouseEvent.rightDown;

        this.targetId = mouseEvent.targetId;
        this.targetNodeName = mouseEvent.targetNodeName;
        this.originalEvent = mouseEvent.originalEvent;
        this.shiftPressed = Tundra.input.keyboard.pressed["shift"];
    }
});

var TundraScene = SceneWrapper.$extend(
{
    __init__ : function()
    {
        this.$super();
    },

    entities : function()
    {
        var result = [];
        var entities = Tundra.scene.entities;
        for (var i = 0; i < entities.length; i++)
            if (isNotNull(entities[i]))
                result.push(__(TundraEntity, entities[i]));

        return result;
    },

    entityById : function(entityId)
    {
        var entityPtr = Tundra.scene.entityById(entityId);
        if (entityPtr !== null && entityPtr !== undefined)
            return __(TundraEntity, entityPtr);

        return null;
    },

    createEntity : function(id, components, change, replicated, componentsReplicated)
    {
        if (isNull(replicated))
            replicated = true;
        if (isNull(componentsReplicated))
            componentsReplicated = replicated;
        if (isNotNull(replicated) && isNull(change))
            change = replicated ? AttributeChange.Replicated : AttributeChange.LocalOnly;
        if (isNull(id) || id == 0)
        {
            if (replicated)
                id = Tundra.scene.nextFreeId();
            else
                id = Tundra.scene.nextFreeIdLocal();
        }

        var entity = Tundra.scene.createEntity(id, components, change, replicated, componentsReplicated);
        return __(TundraEntity, entity);
    },

    removeEntity : function(entityId)
    {
        Tundra.scene.removeEntity(entityId);
    },

    deserializeFrom : function(str)
    {
        var entity = JSON.parse(str);
        var entityPtr = this.entityById(entity.id);
        if (isNull(entityPtr))
            entityPtr = this.createEntity(entity.id, [], null, !entity.local);

        if (isNotNull(entityPtr))
            entityPtr.deserialize(entity);
    },

    registeredComponents : function()
    {
        return Scene.registeredComponentsList();
    },

    doesAllowSameNamedComponents : function()
    {
        return false;
    },

    componentNameWithPrefix : function(componentName)
    {
        return IComponent.ensureComponentNamePrefix(componentName);
    },

    componentNameInHumanFormat : function(typeName)
    {
        if (typeName.indexOf("EC_") == 0)
        {
            var compNameNoEC = typeName.substring(3);
            if (compNameNoEC == "DynamicComponent")
                compNameNoEC = "Dynamic";

            return compNameNoEC;
        }
        else
            return typeName;
    },

    doRaycast : function(x, y, selectionLayer)
    {
        var result = Tundra.renderer.raycast(x, y, selectionLayer);
        return new TundraRaycastResult(result);
    },

    isAttributeAtomic : function(attrTypeId)
    {
        return (attrTypeId === Attribute.String ||
                attrTypeId === Attribute.Int ||
                attrTypeId === Attribute.Real ||
                attrTypeId === Attribute.Bool ||
                attrTypeId === Attribute.UInt ||
                attrTypeId === Attribute.AssetReference ||
                attrTypeId === Attribute.EntityReference ||
                attrTypeId === Attribute.QVariant);
    },

    isAttributeBool : function(attrTypeId)
    {
        return (attrTypeId === Attribute.Bool);
    },

    /// AssetReferenceList and QVariantList technically are arrays
    isAttributeArray : function(attrTypeId)
    {
        return (attrTypeId === Attribute.AssetReferenceList ||
                attrTypeId === Attribute.QVariantList);
    },

    /// Transform is the most complex attribute we have
    isAttributeTransform : function(attrTypeId)
    {
        return (attrTypeId === Attribute.Transform);
    },

    isAttributeColor : function(attrTypeId)
    {
        return (attrTypeId === Attribute.Color);
    },

    /// Color/QPoint/Float2, Float3, Float4/Quat are tuples
    /// returns number of elements in the tuple, or 0 if not tuple
    isAttributeTuple : function(attrTypeId)
    {
        if (attrTypeId === Attribute.Color ||
           attrTypeId === Attribute.Float4 ||
           attrTypeId === Attribute.Quat)
            return 4;
        else if (attrTypeId === Attribute.Float3)
            return 3;
        else if (attrTypeId === Attribute.Float2 ||
                attrTypeId === Attribute.QPoint)
            return 2;
        else
            return 0;
    },

    // Returns a type name for a given type ID
    attributeTypeToName : function(attrTypeId)
    {
        return Attribute.toTypeName(attrTypeId);
    },

    attributeTypeIds : function()
    {
        return Attribute.typeIds();
    },

    reset : function()
    {
        Tundra.scene.reset();
    },

    unsubscribe : function(subscription)
    {
        Tundra.events.unsubscribe(subscription);
    },

    entityCreated : function(context, callback)
    {
        this.registerCallback("onEntityCreated", context, callback);
        return Tundra.scene.onEntityCreated(this, this._onEntityCreated);
    },

    entityRemoved : function(context, callback)
    {
        this.registerCallback("onEntityRemoved", context, callback);
        return Tundra.scene.onEntityRemoved(this, this._onEntityRemoved);
    },

    componentCreated : function(context, callback)
    {
        this.registerCallback("onComponentCreated", context, callback);
        return Tundra.scene.onComponentCreated(this, this._onComponentCreated);
    },

    componentRemoved : function(context, callback)
    {
        this.registerCallback("onComponentRemoved", context, callback);
        return Tundra.scene.onComponentRemoved(this, this._onComponentRemoved);
    },

    attributeChanged : function(context, callback)
    {
        this.registerCallback("onAttributeChanged", context, callback);
        return Tundra.scene.onAttributeChanged(this, this._onAttributeChanged);
    },

    sceneReset : function(context, callback)
    {
        this.registerCallback("onSceneReset", context, callback);
        return Tundra.scene.onReset(this, this._onSceneReset);
    },

    _onEntityCreated : function(entityPtr)
    {
        var entity = __(TundraEntity, entityPtr);
        this.callback("onEntityCreated", entity);
    },

    _onEntityRemoved : function(entityPtr)
    {
        var entity = __(TundraEntity, entityPtr);
        this.callback("onEntityRemoved", entity);
        if (IEditor.Instance.transformEditor)
        {
            for (var i = IEditor.Instance.transformEditor.targets.length - 1; i >= 0; i--) {
                var target = IEditor.Instance.transformEditor.targets[i].parentEntity;
                if (target.id == entity.id)
                {
                    IEditor.Instance.transformEditor.clearSelection();
                    break;
                }
            };
        }
    },

    _onComponentCreated : function(entityPtr, componentPtr)
    {
        var entity = __(TundraEntity, entityPtr);
        var component = __(TundraComponent, componentPtr);

        this.callback("onComponentCreated", entity, component);
    },

    _onComponentRemoved : function(entityPtr, componentPtr)
    {
        var entity = __(TundraEntity, entityPtr);
        var component = __(TundraComponent, componentPtr);

        this.callback("onComponentRemoved", entity, component);

        if (IEditor.Instance.transformEditor)
        {
            for (var i = IEditor.Instance.transformEditor.targets.length - 1; i >= 0; i--) {
                var targetComp = IEditor.Instance.transformEditor.targets[i];
                var target = IEditor.Instance.transformEditor.targets[i].parentEntity;
                if (target.id == entity.id && targetComp.id == componentPtr.id)
                {
                    IEditor.Instance.transformEditor.clearSelection();
                    break;
                }
            };
        }
    },

    _onAttributeChanged : function(entityPtr, componentPtr, attributeIndex, attributeName, attributeValue)
    {
        var entity = __(TundraEntity, entityPtr);
        var component = __(TundraComponent, componentPtr);

        this.callback("onAttributeChanged", entity, component, attributeIndex, attributeName, attributeValue);
    },

    _onSceneReset : function()
    {
        this.callback("onSceneReset");
    },

    logInfo : function(text)
    {
        Tundra.client.logInfo("[Editor]: " + text);
    },

    logWarning : function(text)
    {
        Tundra.client.logWarning("[Editor]: " + text);
    },

    logError : function(text)
    {
        Tundra.client.logError("[Editor]: " + text);
    }
});

var TundraEntity = EntityWrapper.$extend(
{
    __init__ : function(entityPtr)
    {
        this.$super(entityPtr.id, entityPtr.name, entityPtr.local, entityPtr.temporary);
        this._ptr = entityPtr;

        this.callbacks = {};

        // entityPtr.InterfaceDesignerWrapper = this;
    },

    setName : function(name)
    {
        if (this.expired())
            return;

        this.name = name;
        this._ptr.setName(name);
    },

    getName : function()
    {
        return this._ptr.getName();
    },

    components : function()
    {
        var result = [];
        if (this.expired())
            return result;

        for (var i = 0; i < this._ptr.components.length; i++)
        {
            var componentPtr = this._ptr.components[i];
            result.push(__(TundraComponent, componentPtr));
        }

        return result;
    },

    createComponent : function(typeName, name, isLocal)
    {
        if (this.expired())
            return null;

        var attrChange = isLocal ? AttributeChange.LocalOnly : AttributeChange.Replicated;
        var componentPtr = this._ptr.createComponent(typeName, name, attrChange);
        if (isNotNull(componentPtr))
            return __(TundraComponent, componentPtr);

        return null;
    },

    hasComponent : function(type, name)
    {
        return isNotNull(this.getComponent(type, name));
    },

    getComponent : function(type, name)
    {
        if (this.expired())
            return null;

        var componentPtr = this._ptr.getComponent(type, name);
        if (componentPtr !== null && componentPtr !== undefined)
            return __(TundraComponent, componentPtr);

        return null;
    },

    componentById : function(componentId)
    {
        if (this.expired())
            return null;

        var componentPtr = this._ptr.getComponentById(componentId);
        if (componentPtr !== null && componentPtr !== undefined)
            return __(TundraComponent, componentPtr);

        return null;
    },

    removeComponent : function(componentId)
    {
        if (this.expired())
            return;

        this._ptr.removeComponent(componentId);
    },

    serialize : function()
    {
        var result = {};

        result.id = this.id;
        result.name = this.name;
        result.local = this.local;
        result.temporary = this.temporary;

        result.components = [];
        var comps = this.components();
        for (var i = 0; i < comps.length; i++)
            result.components.push(comps[i].serialize());

        return JSON.stringify(result);
    },

    deserialize : function(entity)
    {
        for (var i = 0; i < entity.components.length; i++)
        {
            var component = JSON.parse(entity.components[i]);
            var componentPtr = this.createComponent(component.type, component.name);
            if (isNotNull(componentPtr))
                componentPtr.deserialize(component);
        }
    },
});

var TundraComponent = ComponentWrapper.$extend(
{
    __init__ : function(componentPtr)
    {
        this.$super(componentPtr.id, componentPtr.name, componentPtr.typeName, componentPtr.parentEntity.id);
        this._ptr = componentPtr;

        this.callbacks = {};

        // componentPtr.InterfaceDesignerWrapper = this;
    },

    isDynamic : function()
    {
        if (this.expired())
            return false;

        return this._ptr.isDynamic();
    },

    setTemporary : function(temporary)
    {
        if (this.expired())
            return;

        this._ptr.temporary = temporary;
    },

    attributes : function()
    {
        var result = [];
        if (this.expired())
            return result;

        for (var i in this._ptr.attributes)
        {
            var attributePtr = this._ptr.attributes[i];
            if (isNotNull(attributePtr))
                result.push(__(TundraAttribute, attributePtr, this));
        }

        return result;
    },

    createAttribute : function(typeId, name)
    {
        if (this.expired())
            return null;

        return (this.isDynamic() && this._ptr.createAttribute(typeId, name, null, true));
    },

    attributeByName : function(name)
    {
        if (this.expired())
            return null;

        var attributePtr = this._ptr.attributes[name];
        if (isNotNull(attributePtr))
            return __(TundraAttribute, attributePtr, this);

        return null;
    },

    getAttributeByIndex : function(index)
    {
        if (this.expired())
            return null;

        return __(TundraAttribute, this._ptr.getAttributeByIndex(index), this);
    },

    removeAttribute : function(index)
    {
        if (this.expired())
            return false;

        return (this.isDynamic() && this._ptr.removeAttribute(index));
    },

    serialize : function()
    {
        var result = {};

        result.id = this.id;
        result.name = this.name;
        result.type = this.typeName;
        result.local = this.local;
        result.temporary = this.temporary;
        result.attributes = [];

        var attrs = this.attributes();
        for (var i = 0; i < attrs.length; i++)
            result.attributes.push(attrs[i].serialize());

        return JSON.stringify(result);
    },

    deserialize : function(component)
    {
        var attributes = component.attributes;
        for (var i = 0; i < attributes.length; i++)
        {
            var attr = JSON.parse(attributes[i]);
            var attrPtr = null;
            if (this.isDynamic())
            {
                var success = this.createAttribute(attr.typeId, attr.name);
                if (success)
                    attrPtr = this.attributeByName(attr.name);
            }
            else
                attrPtr = this.getAttributeByIndex(attr.index);

            if (isNotNull(attrPtr))
                attrPtr.deserialize(attr);
        }
    },

    onAttributeAdded : function(context, callback)
    {
        if (this.expired())
            return;

        if (!this.isDynamic())
            return;

        this.registerCallback("onAttributeAdded", context, callback);
        return this._ptr.onAttributeAdded(this, this._onAttributeAdded);
    },

    onAttributeAboutToBeRemoved : function(context, callback)
    {
        if (this.expired())
            return;

        if (!this.isDynamic())
            return;

        this.registerCallback("onAttributeAboutToBeRemoved", context, callback);
        return this._ptr.onAttributeAboutToBeRemoved(this, this._onAttributeAboutToBeRemoved);
    },

    _onAttributeAdded : function(component, attribute)
    {
        var componentPtr = __(TundraComponent, component);
        var attributePtr = __(TundraAttribute, attribute, componentPtr);

        this.callback("onAttributeAdded", componentPtr, attributePtr);
    },

    _onAttributeAboutToBeRemoved : function(component, attributeIndex, attributeName)
    {
        var componentPtr = __(TundraComponent, component);

        this.callback("onAttributeAboutToBeRemoved", componentPtr, attributeIndex, attributeName);
    }
});

var TundraAttribute = AttributeWrapper.$extend(
{
    __init__ : function(attributePtr, owner)
    {
        var parent = null;
        if (isNull(owner))
            parent = __(TundraComponent, attributePtr.owner);
        else
            parent = owner;

        this.$super(attributePtr.index, attributePtr.typeId, attributePtr.name, parent);
        this._ptr = attributePtr;

        // attributePtr.InterfaceDesignerWrapper = this;
    },

    get : function()
    {
        if (this.expired())
            return null;

        return this._ptr.getClone();
    },

    set : function(value)
    {
        if (this.expired())
            return;

        this._ptr.set(value);
    },

    serialize : function()
    {
        var result = {
            name : this.name,
            typeId : this.typeId,
            index : this.index
        };

        var value = this.get();
        if (this.typeId === Attribute.Transform)
            result.value = {
                pos : value.pos,
                rot : value.rot,
                scale : value.scale
            };
        else
            result.value = value;

        return JSON.stringify(result);
    },

    deserialize : function(attribute)
    {
        if (attribute.typeId === Attribute.Transform)
        {
            var attrValue = attribute.value;
            var pos = new THREE.Vector3(attrValue.pos.x, attrValue.pos.y, attrValue.pos.z);
            var rot = new THREE.Vector3(attrValue.rot.x, attrValue.rot.y, attrValue.rot.z);
            var scale = new THREE.Vector3(attrValue.scale.x, attrValue.scale.y, attrValue.scale.z);

            var transform = new Transform(pos, rot, scale);
            this.set(transform);
        }
        else
            this.set(attribute.value)
    }
});

var TundraRaycastResult = RaycastResult.$extend(
{
    __init__ : function(raycastResult)
    {
        this.$super();

        if (isNotNull(raycastResult.entity))
            this.entity = __(TundraEntity, raycastResult.entity);
        if (isNotNull(raycastResult.component))
            this.component = __(TundraComponent, raycastResult.component);

        this.pos = raycastResult.pos;
        this.distance = raycastResult.distance;
        this.submesh = raycastResult.submesh;
        this.faceIndex = raycastResult.faceIndex;
        this.ray = raycastResult.ray;
    }
});

var TundraEditor = IEditor.$extend(
{
    __classvars__ :
    {
        scene : null
    },

    __init__ : function(options)
    {
        this.$super(options);

        $("head").append('<link rel="stylesheet" href="../src/application/editor/lib/skin-win8/ui.fancytree.css">');

        this.meshRefs = {
            "Ball" : "http://meshmoon.data.s3.amazonaws.com/asset-library/meshes/primitives/Sphere.mesh",
            "Cube" : "http://meshmoon.data.s3.amazonaws.com/asset-library/meshes/primitives/Cube.mesh",
            "Cone" : "http://meshmoon.data.s3.amazonaws.com/asset-library/meshes/primitives/Cone.mesh",
            "Cylinder" : "http://meshmoon.data.s3.amazonaws.com/asset-library/meshes/primitives/Cylinder.mesh"
        };

        this.axisHelper = new THREE.AxisHelper(100);
        this.gridHelper = new THREE.GridHelper(100,5);
        this.gridHelper.setColors(new THREE.Color(0xFF0000), new THREE.Color(0x000000));
    },

    /* virtual */
    defaultFontConfig : function()
    {
        return {
            "font-family"    : '"Roboto", sans-serif',
            "font-size"      : "14px",
            "text-transform" : "uppercase"
        };
    },

    /* virtual */
    defaultMonospaceFontConfig : function()
    {
        return {
            "font-family" : '"Source Code Pro", monospace'
        };
    },

    /* virtual */
    isConnected : function()
    {
        return Tundra.client.isConnected();
    },

    /* virtual */
    width : function()
    {
        return this.container().width();
    },

    /* virtual */
    height : function()
    {
        var containerHeight = this.container().height();
        var taskbarHeight = (this.taskbar() ? this.taskbar().height() : 0);
        return containerHeight - taskbarHeight;
    },

    taskbar : function()
    {
        return (Tundra.usingPolymer() && Tundra.ui.taskbar ? undefined : Tundra.ui.taskbar);
    },

    container : function()
    {
        return (Tundra.usingPolymer() ? $("body") : Tundra.container);
    },

    /* pure virtual */
    addWidget : function(element, type)
    {
        $("body").append(element);

        element._tundraType = type;
        if (!Array.isArray(this._tundraElements))
            this._tundraElements = [];
        this._tundraElements.push(element);
    },

    setEnabled : function(enabled)
    {
        this.$super(enabled);

        if (!Array.isArray(this._tundraElements))
            return;

        for (var i = 0; i < this._tundraElements.length; i++)
        {
            var element = this._tundraElements[i];
            if (element._tundraType === "top")
            {
                Tundra.container.css({
                    top    : (enabled ? element.outerHeight(true) : ""),
                    height : (enabled ? "calc(100% - " + element.outerHeight(true) + "px)" : "100%")
                });
            }
            else if (element._tundraType === "right")
            {
                Tundra.container.css({
                    width : (enabled ? "calc(100% - " + element.outerWidth(true) + "px)" : "100%")
                });
            }
        };

        Tundra.ui.onWindowResizeDOM();
        AsyncHelper.async(Tundra.ui.onWindowResizeDOM.bind(Tundra.ui));
    },

    /* pure virtual */
    registerClientConnectedCallback : function(context, callback)
    {
        Tundra.client.onConnected(context, callback);
    },

    /* pure virtual */
    registerKeyEventCallback : function(context, callback)
    {
        this.registerCallback("onKeyEvent", context, callback);
        Tundra.input.onKeyEvent(this, this.onKeyEvent, 1000);
    },

    /* pure virtual */
    registerMouseEventCallback : function(context, callback)
    {
        this.registerCallback("onMouseEvent", context, callback);
        Tundra.input.onMousePress(this, this.onMouseEvent, 1000);
        Tundra.input.onMouseRelease(this, this.onMouseEvent, 1000);
    },

    /* pure virtual */
    registerResizeEventCallback : function(context, callback)
    {
        this.registerCallback("onResizeEvent", context, callback);
        Tundra.ui.onWindowResize(this, this.onResizeEvent);
    },

    registerSceneObject : function()
    {
        TundraEditor.scene = new TundraScene();
        return TundraEditor.scene;
    },

    onKeyEvent : function(keyEvent)
    {
        var wrapper = new TundraKeyEvent(keyEvent);
        this.callback("onKeyEvent", wrapper);
        return (!wrapper.suppressed);
    },

    onMouseEvent : function(mouseEvent)
    {
        var wrapper = new TundraMouseEvent(mouseEvent);
        this.callback("onMouseEvent", wrapper);

        // @todo Fix this correctly by doing actions like selecting entity on "release" instead of "press"
        // this has to happen in InterfaceDesigner-main.js not here. But we need to provide it enough info
        // as in if left button was down on the previous "press".
        var suppressed = wrapper.suppressed;
        if (mouseEvent.type === "release")
        {
            suppressed = (this._lastMouseSuppressed === true);
            this._lastMouseSuppressed = false;
        }
        else
            this._lastMouseSuppressed = wrapper.suppressed;
        return (!wrapper.suppressed);
    },

    onResizeEvent : function(width, height)
    {
        var body = $("body");
        this.callback("onResizeEvent", body.width(), body.height());
    },

    initTransformEditor : function()
    {
        this.transformEditor = Tundra.Classes.PlaceableUtils.Gizmo;
        Tundra.events.subscribe("TransformEditor.MultiTransform", function(states) {
            this.multiTransformCommand(states);
        }.bind(this));
    },

    createPrimitive : function(type)
    {
        this.undoStack.pushAndExec(new CreatePrimitiveCommand(TundraEditor.scene, type, this.meshRefs[type]));
    },

    createMovable : function()
    {
        this.addEntityCommand(["EC_Placeable"], "movable", true);
    },

    createDrawable : function()
    {
        this.addEntityCommand(["EC_Placeable", "EC_Mesh"], "drawable", true);
    },

    createScript : function()
    {
        this.addEntityCommand(["EC_Script"], "script", true);
    },

    showGrid : function()
    {
        Tundra.renderer.scene.add(this.gridHelper);
    },

    hideGrid : function()
    {
        Tundra.renderer.scene.remove(this.gridHelper);
    },

    showAxes : function()
    {
        Tundra.renderer.scene.add(this.axisHelper);
    },

    hideAxes : function()
    {
        Tundra.renderer.scene.remove(this.axisHelper);
    },

    addEntityCommand : function(components, entityName, replicated)
    {
        this.undoStack.pushAndExec(new AddEntityCommand(TundraEditor.scene, components, entityName, replicated));
    },

    removeEntityCommand : function(entityPtr)
    {
        this.undoStack.pushAndExec(new RemoveEntityCommand(TundraEditor.scene, entityPtr));
    },

    addComponentCommand : function(entityId, compType, compName, isLocal, temporary)
    {
        this.undoStack.pushAndExec(new AddComponentCommand(TundraEditor.scene, entityId, compType, compName, isLocal, temporary));
    },

    removeComponentCommand : function(componentPtr)
    {
        this.undoStack.pushAndExec(new RemoveComponentCommand(TundraEditor.scene, componentPtr));
    },

    addAttributeCommand : function(componentPtr, attrTypeId, attrName)
    {
        var existing = componentPtr.attributeByName(attrName);
        if (isNotNull(existing))
            return false;

        this.undoStack.pushAndExec(new AddAttributeCommand(TundraEditor.scene, componentPtr, attrName, attrTypeId));
        return true;
    },

    removeAttributeCommand : function(attributePtr)
    {
        this.undoStack.pushAndExec(new RemoveAttributeCommand(TundraEditor.scene, attributePtr));
    },

    changeAttributeCommand : function(attributePtr, newValue)
    {
        this.undoStack.pushAndExec(new AttributeChangeCommand(TundraEditor.scene, attributePtr, newValue));
    },

    multiTransformCommand : function(states)
    {
        this.undoStack.pushCommand(new MultiTransformCommand(states));
    },

    save : function(filename)
    {
        var sceneTxml = Tundra.scene.serializeToXml();
        var sceneTxmlString = new XMLSerializer().serializeToString(sceneTxml);
        var blob = new Blob([vkbeautify.xml(sceneTxmlString)], {type: "text/xml;charset=utf-8"});
        saveAs(blob, filename + ".txml");
    },

    load : function(fileObject)
    {
        var reader = new FileReader();
        reader.addEventListener("loadend", function(e)
        {
            var txt = e.target.result;
            var parser = new DOMParser();
            var xmlDoc = parser.parseFromString(txt, "text/xml");
            Tundra.scene.deserializeFromXml(xmlDoc);
        });
        reader.readAsText(fileObject);
    }
});

// Main IApplication object
var EditorApplication = IApplication.$extend(
{
    __init__ : function()
    {
        this.$super("Editor");

        Tundra.events.subscribe("InterfaceDesigner.Toggle", function() {
            if (this.editor)
                this.editor.toggleEditor();
        }.bind(this));

        Tundra.events.subscribe("InterfaceDesigner.SetEnabled", function(enabled) {
            if (this.editor)
                this.editor.setEnabled(enabled === true);
        }.bind(this));

        Tundra.events.subscribe("InterfaceDesigner.Start", function(enabled) {
            this.start();
        }.bind(this));

        // Auto start in dev mode
        if (Tundra.usingRequireJS())
            this.start();
    },

    start : function()
    {
        if (this.started === true || this.editor !== undefined)
            return;
        this.started = true;

        IApplication.loadDependencies(this,
            "lib/jquery.fancytree-all.min.js", "lib/FileSaver.min.js", "lib/vkbeautify.0.99.00.beta.js")
        .done(function()
        {
            this.editor = new TundraEditor({
                type: "webtundra"
            });
        }.bind(this));
    }
})

return EditorApplication;

});
